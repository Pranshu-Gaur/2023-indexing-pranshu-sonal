# -*- coding: utf-8 -*-
"""PQ.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Xv9HbI-ubgEBxuakY0flntBWgerMbeVI
"""

import numpy as np
from scipy.cluster.vq import kmeans2, vq
from scipy.spatial.distance import cdist
import time

def PQ_train(vectors, M, k):
    s = int(vectors.shape[1] / M)                      # Dimension (or length) of a segment.
    codebook = np.empty((M, k, s), np.float32)         
        
    for m in range(M):
        sub_vectors = vectors[:, m*s:(m+1)*s]          # Sub-vectors for segment m.
        codebook[m], label = kmeans2(sub_vectors, k)   # Run k-means clustering for each segment.
        
    return codebook

def PQ_encode(vectors, codebook):
    M, k, s = codebook.shape
    PQ_code = np.empty((vectors.shape[0], M), np.uint8)
    
    for m in range(M):
        sub_vectors = vectors[:, m*s:(m+1)*s]           # Sub-vectors for segment m.     
        centroid_ids, _ = vq(sub_vectors, codebook[m])  # vq returns the nearest centroid Ids.
        PQ_code[:, m] = centroid_ids                    # Assign centroid Ids to PQ_code.
        
    return PQ_code

def PQ_search(query_vector, codebook, PQ_code):
    M, k, s = codebook.shape
    
    distance_table = np.empty((M, k), np.float32)    # Shape is (M, k)    
        
    for m in range(M):
        query_segment = query_vector[m*s:(m+1)*s]    # Query vector for segment m.
        distance_table[m] = cdist([query_segment], codebook[m], "sqeuclidean")[0]
    
    N, M = PQ_code.shape
    distance_table = distance_table.T               # Transpose the distance table to shape (k, M)
    distances = np.zeros((N, )).astype(np.float32)
    idx = []

    for n in range(N):                              # For each PQ Code, lookup the partial distances.
        for m in range(M):
            distances[n] += distance_table[PQ_code[n][m]][m] # Sum the partial distances from all the segments.
    idx = np.argsort(distances)
    return idx, distances

def PQ(points,queries):
  M = 4                     # Number of segments
  k = 32                   # Number of centroids per segment
  vector_dim = 128          # Dimension (length) of a vector
  total_vectors = 1000000   # Number of database vectors
  xb = points
  t1 = time.perf_counter()
  codebook = PQ_train(xb, M, k)
  t2 = time.perf_counter()
  PQ_code = PQ_encode(xb, codebook)
  t3 = time.perf_counter()
  time_s=0
  for i in range(queries.shape[0]+1):
    t4 = time.perf_counter()
    index, distances = PQ_search(queries[i], codebook, PQ_code)
    t5 = time.perf_counter()
    print('Top 10 nearest neighbours for query ',i,' are', index[0:10])
    print('Query search time:', t5-t4, 's')
    time_s+=(t5-t4)

  print('Codebook generation time:', t2-t1, 's')
  print('Encoding(PQ_code) time for dataset:', t3-t2, 's')
  print('Average query search time:', time_s/(queries.shape[0]))